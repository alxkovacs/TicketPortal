{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { catchError, throwError, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport { EventService } from './event.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TicketService {\n  constructor(http) {\n    this.http = http;\n    // Segédfüggvény az EventService-hez való hozzáféréshez\n    // Injectálási körkörös függőség elkerülése miatt\n    this.eventService = null;\n  }\n  /**\n   * Segédfüggvény az EventService objektum lekéréséhez\n   * Körkörös függőség elkerülése miatt szükséges\n   */\n  getEventService() {\n    if (!this.eventService) {\n      this.eventService = new EventService(this.http);\n    }\n    return this.eventService;\n  }\n  /**\n   * Jegy vásárlása a megadott eseményhez és kategóriához\n   * @param eventId Esemény azonosító\n   * @param categoryName A jegy kategória neve\n   * @param quantity Megvásárolni kívánt jegyek száma\n   */\n  purchaseTicket(eventId, categoryName, quantity) {\n    // A backend kód megtekintése után látjuk, hogy a backend a kategória NEVÉT várja, nem az azonosítóját!\n    // A backend kódrészlet:\n    // const ticketCategory = event.ticketCategories.find((cat) => cat.name === category);\n    const endpoint = `${environment.apiUrl}/tickets`;\n    // A backendnek küldünk egy kérést, ami tartalmazza a mennyiséget is\n    const requestPayload = {\n      eventId: eventId,\n      category: categoryName,\n      quantity: quantity // A vásárolni kívánt jegyek száma\n    };\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Jegyvásárlás indul. Esemény: ${eventId}, Kategória: ${categoryName}, Mennyiség: ${quantity} (Autentikációval)`);\n    return this.http.post(endpoint, requestPayload, {\n      headers\n    }).pipe(map(response => {\n      console.log(`[${new Date().toLocaleTimeString()}] Sikeres jegyvásárlás API válasz:`, response);\n      return response;\n    }), catchError(error => {\n      console.error(`[${new Date().toLocaleTimeString()}] Hiba a jegyvásárlás során:`, error);\n      console.log(`[${new Date().toLocaleTimeString()}] Pontos request payload:`, requestPayload);\n      return this.handleJegyvasarlasError(error);\n    }));\n  }\n  /**\n   * Jegyvásárláskor keletkezett hibák kezelése\n   * Részletes diagnosztikai naplózással\n   */\n  handleJegyvasarlasError(error) {\n    console.error('Részletes vásárlási hiba:', {\n      status: error.status,\n      message: error.message,\n      errorBody: error.error\n    });\n    if (error.status === 500) {\n      console.error('500-as szerver hiba történt. Lehetséges problémák:');\n      console.error('1. A backend request formátuma és a küldött adatok nem egyeznek');\n      console.error('2. Szerverhiba a jegy létrehozása közben');\n      console.error('3. Adatbázishiba vagy az esemény/kategória nem található');\n    }\n    if (error.error && error.error.errors && Array.isArray(error.error.errors)) {\n      console.log('A szerver által jelentett hibák:');\n      error.error.errors.forEach((err, index) => {\n        console.log(`Hiba #${index + 1}:`, err);\n      });\n    }\n    return throwError(() => error);\n  }\n  /**\n   * Felhasználó jegyeinek lekérése\n   * Mindig friss adatokat kér a szervertől\n   * Autentikációs token elküldésével\n   */\n  getUserTickets(timestamp) {\n    let params = {};\n    // Ha időbélyeg van, akkor azt is elküldjük, hogy friss adatokat kapjunk\n    if (timestamp) {\n      params.t = timestamp.toString();\n    }\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`[${new Date().toLocaleTimeString()}] Felhasználó jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    return this.http.get(endpoint, {\n      params,\n      headers\n    });\n  }\n  /**\n   * Jegy lemondása\n   * @param ticketId A lemondani kívánt jegy azonosítója\n   */\n  cancelTicket(ticketId) {\n    const endpoint = `${environment.apiUrl}/tickets/${ticketId}/cancel`;\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Jegy lemondása, végpont: ${endpoint} (Autentikációval)`);\n    return this.http.patch(endpoint, {}, {\n      headers\n    });\n  }\n  /**\n   * Eseményhez tartozó jegyek lekérése\n   * @param eventId Az esemény azonosítója\n   */\n  getEventTickets(eventId) {\n    const endpoint = `${environment.apiUrl}/tickets/event/${eventId}`;\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Esemény jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    return this.http.get(endpoint, {\n      headers\n    });\n  }\n  /**\n   * JWT token kinyerése a localStorage-ból\n   * Minden API híváshoz hozzáadjuk az Authorization fejlécet\n   */\n  getAuthHeaders() {\n    const token = localStorage.getItem('token');\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'Authorization': token ? `Bearer ${token}` : ''\n    });\n    return headers;\n  }\n  /**\n   * Összes jegy lekérése admin célokra\n   * Csak admin jogosultsággal hívható\n   * @param forceRefresh Ha true, akkor időbélyeget ad a kéréshez a cache elkerüléséhez\n   * @returns Observable az összes jeggyel\n   */\n  getAllTickets(forceRefresh = true) {\n    // Mindig friss adatokat kérünk az adatbázisból\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    // Minden lekérésnél különböző időbélyeg, hogy biztosan ne használjon cache-t\n    let params = {\n      // Mindig friss időbélyeg a cache elkerüléséhez\n      t: new Date().getTime().toString()\n    };\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Jegyek lekérése friss adatokkal: ${endpoint} (Autentikációval)`);\n    return this.http.get(endpoint, {\n      params,\n      headers\n    }).pipe(map(tickets => {\n      console.log(`[${new Date().toLocaleTimeString()}] Adatbázisból lekért jegyek száma: ${tickets.length}`);\n      if (tickets && tickets.length > 0) {\n        console.log(`[${new Date().toLocaleTimeString()}] Adatbázis jegyek részletei:`, tickets.map(t => `${t.category} - ${t.price} Ft`).join(', '));\n      } else {\n        console.log(`[${new Date().toLocaleTimeString()}] Az adatbázis nem tartalmaz jegyeket. Ellenőrizd a bejelentkezést és jogosultságokat.`);\n      }\n      // Mindig csak azt adjuk vissza, amit az adatbázis ad - nincs helyi manipuláció vagy mesterségesen előállított adatok\n      return tickets;\n    }), catchError(error => {\n      console.error(`[${new Date().toLocaleTimeString()}] API hiba a jegyek lekérése közben:`, error);\n      console.error(`[${new Date().toLocaleTimeString()}] Státuszkód: ${error.status}, Üzenet: ${error.message}`);\n      if (error.status === 401 || error.status === 403) {\n        console.error(`[${new Date().toLocaleTimeString()}] Autentikációs hiba - a token valószínűleg lejárt vagy érvénytelen.`);\n      }\n      // Hiba esetén üres tömböt adunk vissza\n      console.log(`[${new Date().toLocaleTimeString()}] Hiba miatt üres jegylista kerül visszaadásra - próbálj újra bejelentkezni.`);\n      return of([]);\n    }));\n  }\n  static {\n    this.ɵfac = function TicketService_Factory(t) {\n      return new (t || TicketService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TicketService,\n      factory: TicketService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpHeaders","catchError","throwError","of","map","environment","EventService","TicketService","constructor","http","eventService","getEventService","purchaseTicket","eventId","categoryName","quantity","endpoint","apiUrl","requestPayload","category","headers","getAuthHeaders","console","log","Date","toLocaleTimeString","post","pipe","response","error","handleJegyvasarlasError","status","message","errorBody","errors","Array","isArray","forEach","err","index","getUserTickets","timestamp","params","t","toString","get","cancelTicket","ticketId","patch","getEventTickets","token","localStorage","getItem","getAllTickets","forceRefresh","getTime","tickets","length","price","join","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["D:\\SZTE_PROGINFO\\programrendszerek_fejlesztese\\TicketPortal\\frontend\\src\\app\\services\\ticket.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';\nimport { Observable, catchError, throwError, forkJoin, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport { Ticket } from '../models/ticket.model';\nimport { Event } from '../models/event.model';\nimport { EventService } from './event.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TicketService {\n  // Segédfüggvény az EventService-hez való hozzáféréshez\n  // Injectálási körkörös függőség elkerülése miatt\n  private eventService: EventService | null = null;\n\n  constructor(private http: HttpClient) {}\n  \n  /**\n   * Segédfüggvény az EventService objektum lekéréséhez\n   * Körkörös függőség elkerülése miatt szükséges\n   */\n  getEventService(): EventService {\n    if (!this.eventService) {\n      this.eventService = new EventService(this.http);\n    }\n    return this.eventService;\n  }\n  \n  /**\n   * Jegy vásárlása a megadott eseményhez és kategóriához\n   * @param eventId Esemény azonosító\n   * @param categoryName A jegy kategória neve\n   * @param quantity Megvásárolni kívánt jegyek száma\n   */\n  purchaseTicket(eventId: string, categoryName: string, quantity: number): Observable<Ticket> {\n    // A backend kód megtekintése után látjuk, hogy a backend a kategória NEVÉT várja, nem az azonosítóját!\n    // A backend kódrészlet:\n    // const ticketCategory = event.ticketCategories.find((cat) => cat.name === category);\n    \n    const endpoint = `${environment.apiUrl}/tickets`;\n    \n    // A backendnek küldünk egy kérést, ami tartalmazza a mennyiséget is\n    const requestPayload = {\n      eventId: eventId,         // Az esemény ID-ja\n      category: categoryName,   // A kategória neve (nem az ID!)\n      quantity: quantity        // A vásárolni kívánt jegyek száma\n    };\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Jegyvásárlás indul. Esemény: ${eventId}, Kategória: ${categoryName}, Mennyiség: ${quantity} (Autentikációval)`);\n    \n    return this.http.post<Ticket>(endpoint, requestPayload, { headers }).pipe(\n      map(response => {\n        console.log(`[${new Date().toLocaleTimeString()}] Sikeres jegyvásárlás API válasz:`, response);\n        return response;\n      }),\n      catchError(error => {\n        console.error(`[${new Date().toLocaleTimeString()}] Hiba a jegyvásárlás során:`, error);\n        console.log(`[${new Date().toLocaleTimeString()}] Pontos request payload:`, requestPayload);\n        return this.handleJegyvasarlasError(error);\n      })\n    );\n  }\n  \n  /**\n   * Jegyvásárláskor keletkezett hibák kezelése\n   * Részletes diagnosztikai naplózással\n   */\n  private handleJegyvasarlasError(error: HttpErrorResponse): Observable<never> {\n    console.error('Részletes vásárlási hiba:', {\n      status: error.status,\n      message: error.message,\n      errorBody: error.error\n    });\n    \n    if (error.status === 500) {\n      console.error('500-as szerver hiba történt. Lehetséges problémák:');\n      console.error('1. A backend request formátuma és a küldött adatok nem egyeznek');\n      console.error('2. Szerverhiba a jegy létrehozása közben');\n      console.error('3. Adatbázishiba vagy az esemény/kategória nem található');\n    }\n    \n    if (error.error && error.error.errors && Array.isArray(error.error.errors)) {\n      console.log('A szerver által jelentett hibák:');\n      error.error.errors.forEach((err: any, index: number) => {\n        console.log(`Hiba #${index + 1}:`, err);\n      });\n    }\n    \n    return throwError(() => error);\n  }\n  \n  /**\n   * Felhasználó jegyeinek lekérése\n   * Mindig friss adatokat kér a szervertől\n   * Autentikációs token elküldésével\n   */\n  getUserTickets(timestamp?: number): Observable<Ticket[]> {\n    let params: any = {};\n    \n    // Ha időbélyeg van, akkor azt is elküldjük, hogy friss adatokat kapjunk\n    if (timestamp) {\n      params.t = timestamp.toString();\n    }\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`[${new Date().toLocaleTimeString()}] Felhasználó jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    \n    return this.http.get<Ticket[]>(endpoint, { params, headers });\n  }\n  \n  /**\n   * Jegy lemondása\n   * @param ticketId A lemondani kívánt jegy azonosítója\n   */\n  cancelTicket(ticketId: string): Observable<void> {\n    const endpoint = `${environment.apiUrl}/tickets/${ticketId}/cancel`;\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Jegy lemondása, végpont: ${endpoint} (Autentikációval)`);\n    \n    return this.http.patch<void>(endpoint, {}, { headers });\n  }\n  \n  /**\n   * Eseményhez tartozó jegyek lekérése\n   * @param eventId Az esemény azonosítója\n   */\n  getEventTickets(eventId: string): Observable<Ticket[]> {\n    const endpoint = `${environment.apiUrl}/tickets/event/${eventId}`;\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Esemény jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    \n    return this.http.get<Ticket[]>(endpoint, { headers });\n  }\n  \n  /**\n   * JWT token kinyerése a localStorage-ból\n   * Minden API híváshoz hozzáadjuk az Authorization fejlécet\n   */\n  private getAuthHeaders(): HttpHeaders {\n    const token = localStorage.getItem('token');\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'Authorization': token ? `Bearer ${token}` : ''\n    });\n    return headers;\n  }\n  \n  /**\n   * Összes jegy lekérése admin célokra  \n   * Csak admin jogosultsággal hívható\n   * @param forceRefresh Ha true, akkor időbélyeget ad a kéréshez a cache elkerüléséhez\n   * @returns Observable az összes jeggyel\n   */\n  getAllTickets(forceRefresh: boolean = true): Observable<Ticket[]> {\n    // Mindig friss adatokat kérünk az adatbázisból\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    \n    // Minden lekérésnél különböző időbélyeg, hogy biztosan ne használjon cache-t\n    let params: any = {\n      // Mindig friss időbélyeg a cache elkerüléséhez\n      t: new Date().getTime().toString() \n    };\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Jegyek lekérése friss adatokkal: ${endpoint} (Autentikációval)`);\n\n    return this.http.get<Ticket[]>(endpoint, { params, headers }).pipe(\n      map(tickets => {\n        console.log(`[${new Date().toLocaleTimeString()}] Adatbázisból lekért jegyek száma: ${tickets.length}`);\n        \n        if (tickets && tickets.length > 0) {\n          console.log(`[${new Date().toLocaleTimeString()}] Adatbázis jegyek részletei:`, \n            tickets.map(t => `${t.category} - ${t.price} Ft`).join(', '));\n        } else {\n          console.log(`[${new Date().toLocaleTimeString()}] Az adatbázis nem tartalmaz jegyeket. Ellenőrizd a bejelentkezést és jogosultságokat.`);\n        }\n        \n        // Mindig csak azt adjuk vissza, amit az adatbázis ad - nincs helyi manipuláció vagy mesterségesen előállított adatok\n        return tickets;\n      }),\n      catchError(error => {\n        console.error(`[${new Date().toLocaleTimeString()}] API hiba a jegyek lekérése közben:`, error);\n        console.error(`[${new Date().toLocaleTimeString()}] Státuszkód: ${error.status}, Üzenet: ${error.message}`);\n        \n        if (error.status === 401 || error.status === 403) {\n          console.error(`[${new Date().toLocaleTimeString()}] Autentikációs hiba - a token valószínűleg lejárt vagy érvénytelen.`);\n        }\n        \n        // Hiba esetén üres tömböt adunk vissza\n        console.log(`[${new Date().toLocaleTimeString()}] Hiba miatt üres jegylista kerül visszaadásra - próbálj újra bejelentkezni.`);\n        return of([]);\n      })\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}