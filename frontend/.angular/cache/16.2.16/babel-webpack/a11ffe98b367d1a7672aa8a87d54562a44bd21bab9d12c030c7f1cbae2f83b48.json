{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class EventService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = `${environment.apiUrl}/events`;\n  }\n  /**\n   * Események lekérése a szerverről\n   * @param timestamp Időbélyeg a cache elkerüléséhez (opcionális)\n   */\n  getEvents(timestamp) {\n    // Ha van timestamp paraméter, hozzáadjuk a kéréshez, hogy elkerüljük a cache-elést\n    let params = new HttpParams();\n    if (timestamp) {\n      params = params.set('t', timestamp.toString());\n    }\n    return this.http.get(this.apiUrl, {\n      params\n    });\n  }\n  /**\n   * Csak jövőbeli események lekérése\n   * Adminok számára az összes esemény elérhető a getEvents metódussal\n   * Ez a metódus pedig csak a jövőbeli eseményeket adja vissza\n   * @param timestamp Időbélyeg a cache elkerüléséhez (opcionális)\n   */\n  getUpcomingEvents(timestamp) {\n    return new Observable(observer => {\n      this.getEvents(timestamp).subscribe({\n        next: events => {\n          // Kiszűrjük a múltbeli eseményeket\n          const currentDate = new Date();\n          const upcomingEvents = events.filter(event => {\n            // Ellenőrizzük, hogy az esemény dátuma jövőbeli-e\n            return new Date(event.date) > currentDate;\n          });\n          observer.next(upcomingEvents);\n          observer.complete();\n        },\n        error: err => {\n          observer.error(err);\n        }\n      });\n    });\n  }\n  getEvent(id) {\n    return this.http.get(`${this.apiUrl}/${id}`);\n  }\n  /**\n   * Új esemény létrehozása\n   * @param eventData Az új esemény adatai\n   */\n  createEvent(eventData) {\n    // Biztositsuk, hogy van legalabb egy jegykategoria\n    let ticketCategories = eventData.ticketCategories || [];\n    if (!Array.isArray(ticketCategories) || ticketCategories.length === 0) {\n      ticketCategories = [{\n        name: 'Alap jegy',\n        price: 1000,\n        availableSeats: 100 // Backend API az \"availableSeats\" nevet várja, nem \"availableTickets\"-et\n      }];\n    }\n    // Átkonvertáljuk a meglévő jegykategoriákat a backend által várt médon\n    ticketCategories = ticketCategories.map(category => {\n      // Clone to avoid mutating the original\n      const convertedCategory = {\n        ...category\n      };\n      // Rename availableTickets to availableSeats if it exists\n      if ('availableTickets' in convertedCategory) {\n        convertedCategory.availableSeats = convertedCategory.availableTickets;\n        delete convertedCategory.availableTickets;\n      } else if (!('availableSeats' in convertedCategory)) {\n        // Ha egyiket sem találjuk, adjunk hozzá alapértelmezetten 100-at\n        convertedCategory.availableSeats = 100;\n      }\n      return convertedCategory;\n    });\n    // Számítsuk ki a teljes jegy mennyiséget\n    const totalTickets = ticketCategories.reduce((sum, category) => sum + (Number(category.availableSeats) || 0), 0);\n    // Készítsünk egy típushelyes új eseményt\n    const newEvent = {\n      title: eventData.title,\n      description: eventData.description,\n      date: new Date(eventData.date).toISOString(),\n      location: eventData.location,\n      imageUrl: eventData.imageUrl || '',\n      ticketCategories: ticketCategories,\n      availableTickets: totalTickets\n    };\n    // Szerző hozzáadása, ha megtalálható\n    try {\n      // Először próbáljuk a user kulcsot\n      const userStr = localStorage.getItem('user');\n      if (userStr) {\n        const userData = JSON.parse(userStr);\n        if (userData && userData.user && userData.user._id) {\n          newEvent.organizer = userData.user._id;\n        } else if (userData && userData._id) {\n          newEvent.organizer = userData._id;\n        }\n      }\n      // Ha nincs, próbáljuk a currentUser kulcsot\n      if (!newEvent.organizer) {\n        const currentUserStr = localStorage.getItem('currentUser');\n        if (currentUserStr) {\n          const currentUserData = JSON.parse(currentUserStr);\n          if (currentUserData && currentUserData._id) {\n            newEvent.organizer = currentUserData._id;\n          }\n        }\n      }\n    } catch (e) {\n      console.error('Hiba a felhasználó ID kiolvasása közben:', e);\n    }\n    console.log('Küldés a szervernek:', newEvent);\n    return this.http.post(this.apiUrl, newEvent);\n  }\n  updateEvent(id, event) {\n    return this.http.put(`${this.apiUrl}/${id}`, event);\n  }\n  deleteEvent(id) {\n    return this.http.delete(`${this.apiUrl}/${id}`);\n  }\n  getOrganizerEvents() {\n    // Feltételezzük, hogy environment.apiUrl már tartalmazza az /api előtagot\n    return this.http.get(`${environment.apiUrl}/users/my-events`);\n  }\n  static {\n    this.ɵfac = function EventService_Factory(t) {\n      return new (t || EventService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: EventService,\n      factory: EventService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpParams","Observable","environment","EventService","constructor","http","apiUrl","getEvents","timestamp","params","set","toString","get","getUpcomingEvents","observer","subscribe","next","events","currentDate","Date","upcomingEvents","filter","event","date","complete","error","err","getEvent","id","createEvent","eventData","ticketCategories","Array","isArray","length","name","price","availableSeats","map","category","convertedCategory","availableTickets","totalTickets","reduce","sum","Number","newEvent","title","description","toISOString","location","imageUrl","userStr","localStorage","getItem","userData","JSON","parse","user","_id","organizer","currentUserStr","currentUserData","e","console","log","post","updateEvent","put","deleteEvent","delete","getOrganizerEvents","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["D:\\SZTE_PROGINFO\\programrendszerek_fejlesztese\\TicketPortal\\frontend\\src\\app\\services\\event.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpParams } from '@angular/common/http';\nimport { Observable, catchError, throwError } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport { Event, NewEvent, TicketCategory } from '../models/event.model';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class EventService {\n  private apiUrl = `${environment.apiUrl}/events`;\n\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Események lekérése a szerverről\n   * @param timestamp Időbélyeg a cache elkerüléséhez (opcionális)\n   */\n  getEvents(timestamp?: number): Observable<Event[]> {\n    // Ha van timestamp paraméter, hozzáadjuk a kéréshez, hogy elkerüljük a cache-elést\n    let params = new HttpParams();\n    if (timestamp) {\n      params = params.set('t', timestamp.toString());\n    }\n    \n    return this.http.get<Event[]>(this.apiUrl, { params });\n  }\n  \n  /**\n   * Csak jövőbeli események lekérése\n   * Adminok számára az összes esemény elérhető a getEvents metódussal\n   * Ez a metódus pedig csak a jövőbeli eseményeket adja vissza\n   * @param timestamp Időbélyeg a cache elkerüléséhez (opcionális)\n   */\n  getUpcomingEvents(timestamp?: number): Observable<Event[]> {\n    return new Observable<Event[]>(observer => {\n      this.getEvents(timestamp).subscribe({\n        next: (events: Event[]) => {\n          // Kiszűrjük a múltbeli eseményeket\n          const currentDate = new Date();\n          const upcomingEvents = events.filter(event => {\n            // Ellenőrizzük, hogy az esemény dátuma jövőbeli-e\n            return new Date(event.date) > currentDate;\n          });\n          \n          observer.next(upcomingEvents);\n          observer.complete();\n        },\n        error: (err) => {\n          observer.error(err);\n        }\n      });\n    });\n  }\n\n  getEvent(id: string): Observable<Event> {\n    return this.http.get<Event>(`${this.apiUrl}/${id}`);\n  }\n\n  /**\n   * Új esemény létrehozása\n   * @param eventData Az új esemény adatai\n   */\n  createEvent(eventData: any): Observable<Event> {\n    // Biztositsuk, hogy van legalabb egy jegykategoria\n    let ticketCategories = eventData.ticketCategories || [];\n    if (!Array.isArray(ticketCategories) || ticketCategories.length === 0) {\n      ticketCategories = [{\n        name: 'Alap jegy',\n        price: 1000,\n        availableSeats: 100  // Backend API az \"availableSeats\" nevet várja, nem \"availableTickets\"-et\n      }];\n    }\n    \n    // Átkonvertáljuk a meglévő jegykategoriákat a backend által várt médon\n    ticketCategories = ticketCategories.map((category: any) => {\n      // Clone to avoid mutating the original\n      const convertedCategory = {...category};\n      // Rename availableTickets to availableSeats if it exists\n      if ('availableTickets' in convertedCategory) {\n        convertedCategory.availableSeats = convertedCategory.availableTickets;\n        delete convertedCategory.availableTickets;\n      } else if (!('availableSeats' in convertedCategory)) {\n        // Ha egyiket sem találjuk, adjunk hozzá alapértelmezetten 100-at\n        convertedCategory.availableSeats = 100;\n      }\n      return convertedCategory;\n    });\n    \n    // Számítsuk ki a teljes jegy mennyiséget\n    const totalTickets = ticketCategories.reduce(\n      (sum: number, category: any) => sum + (Number(category.availableSeats) || 0), 0\n    );\n\n    // Készítsünk egy típushelyes új eseményt\n    const newEvent: NewEvent = {\n      title: eventData.title,\n      description: eventData.description,\n      date: new Date(eventData.date).toISOString(),\n      location: eventData.location,\n      imageUrl: eventData.imageUrl || '',\n      ticketCategories: ticketCategories,\n      availableTickets: totalTickets\n    };\n    \n    // Szerző hozzáadása, ha megtalálható\n    try {\n      // Először próbáljuk a user kulcsot\n      const userStr = localStorage.getItem('user');\n      if (userStr) {\n        const userData = JSON.parse(userStr);\n        if (userData && userData.user && userData.user._id) {\n          newEvent.organizer = userData.user._id;\n        } else if (userData && userData._id) {\n          newEvent.organizer = userData._id;\n        }\n      }\n      \n      // Ha nincs, próbáljuk a currentUser kulcsot\n      if (!newEvent.organizer) {\n        const currentUserStr = localStorage.getItem('currentUser');\n        if (currentUserStr) {\n          const currentUserData = JSON.parse(currentUserStr);\n          if (currentUserData && currentUserData._id) {\n            newEvent.organizer = currentUserData._id;\n          }\n        }\n      }\n    } catch (e) {\n      console.error('Hiba a felhasználó ID kiolvasása közben:', e);\n    }\n    \n    console.log('Küldés a szervernek:', newEvent);\n    return this.http.post<Event>(this.apiUrl, newEvent);\n  }\n\n  updateEvent(id: string, event: Event): Observable<Event> {\n    return this.http.put<Event>(`${this.apiUrl}/${id}`, event);\n  }\n\n  deleteEvent(id: string): Observable<void> {\n    return this.http.delete<void>(`${this.apiUrl}/${id}`);\n  }\n\n  getOrganizerEvents(): Observable<Event[]> {\n    // Feltételezzük, hogy environment.apiUrl már tartalmazza az /api előtagot\n    return this.http.get<Event[]>(`${environment.apiUrl}/users/my-events`);\n  }\n\n  // A purchaseTicket metódus most már a TicketService-be került át\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}