{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { catchError, throwError, of } from 'rxjs';\nimport { map, tap } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport { EventService } from './event.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TicketService {\n  constructor(http) {\n    this.http = http;\n    // Segédfüggvény az EventService-hez való hozzáféréshez\n    // Injectálási körkörös függőség elkerülése miatt\n    this.eventService = null;\n  }\n  /**\n   * Segédfüggvény az EventService objektum lekéréséhez\n   * Körkörös függőség elkerülése miatt szükséges\n   */\n  getEventService() {\n    if (!this.eventService) {\n      this.eventService = new EventService(this.http);\n    }\n    return this.eventService;\n  }\n  /**\n   * Jegy vásárlása a megadott eseményhez és kategóriához\n   * @param eventId Esemény azonosító\n   * @param categoryName A jegy kategória neve\n   * @param quantity Megvásárolni kívánt jegyek száma\n   */\n  purchaseTicket(eventId, categoryName, quantity) {\n    // A backend kód megtekintése után látjuk, hogy a backend a kategória NEVÉT várja, nem az azonosítóját!\n    // A backend kódrészlet:\n    // const ticketCategory = event.ticketCategories.find((cat) => cat.name === category);\n    const endpoint = `${environment.apiUrl}/tickets`;\n    // A backendnek küldünk egy kérést, ami tartalmazza a mennyiséget is\n    const requestPayload = {\n      eventId: eventId,\n      category: categoryName,\n      quantity: quantity // A vásárolni kívánt jegyek száma\n    };\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Jegyvásárlás indul. Esemény: ${eventId}, Kategória: ${categoryName}, Mennyiség: ${quantity} (Autentikációval)`);\n    return this.http.post(endpoint, requestPayload, {\n      headers\n    }).pipe(map(response => {\n      console.log(`[${new Date().toLocaleTimeString()}] Sikeres jegyvásárlás API válasz:`, response);\n      return response;\n    }), catchError(error => {\n      console.error(`[${new Date().toLocaleTimeString()}] Hiba a jegyvásárlás során:`, error);\n      console.log(`[${new Date().toLocaleTimeString()}] Pontos request payload:`, requestPayload);\n      return this.handleJegyvasarlasError(error);\n    }));\n  }\n  /**\n   * Jegyvásárláskor keletkezett hibák kezelése\n   * Részletes diagnosztikai naplózással\n   */\n  handleJegyvasarlasError(error) {\n    console.error('Részletes vásárlási hiba:', {\n      status: error.status,\n      message: error.message,\n      errorBody: error.error\n    });\n    if (error.status === 500) {\n      console.error('500-as szerver hiba történt. Lehetséges problémák:');\n      console.error('1. A backend request formátuma és a küldött adatok nem egyeznek');\n      console.error('2. Szerverhiba a jegy létrehozása közben');\n      console.error('3. Adatbázishiba vagy az esemény/kategória nem található');\n    }\n    if (error.error && error.error.errors && Array.isArray(error.error.errors)) {\n      console.log('A szerver által jelentett hibák:');\n      error.error.errors.forEach((err, index) => {\n        console.log(`Hiba #${index + 1}:`, err);\n      });\n    }\n    return throwError(() => error);\n  }\n  /**\n   * Felhasználó jegyeinek lekérése - garantáltan friss adatokkal\n   * @param timestamp Időbélyeg a cache elkerüléséhez (opcionális)\n   */\n  getUserTickets(timestamp) {\n    // Egyedi időbélyeg a lekéréshez - ha nincs megadva, generálunk egyet\n    const currentTime = new Date().getTime();\n    const requestTimestamp = timestamp || currentTime;\n    // Kérés paraméterek a cache elkerüléséhez\n    const params = {\n      t: requestTimestamp.toString(),\n      _: Math.random().toString(36),\n      nocache: 'true' // Cache letiltás jelzés\n    };\n    // API hívás a szükséges autentikációs fejlécekkel és cache-előző beállításokkal\n    const headers = this.getAuthHeaders();\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`[${new Date().toLocaleTimeString()}] Felhasználó jegyeinek lekérése: ${endpoint} (időbélyeg: ${requestTimestamp})`);\n    // Kérés elküldése és hibakezelés\n    return this.http.get(endpoint, {\n      params,\n      headers\n    }).pipe(catchError(error => {\n      console.error(`[${new Date().toLocaleTimeString()}] Hiba a felhasználó jegyeinek lekérése közben:`, error);\n      // Hiba esetén visszaadunk egy üres listát, hogy az alkalmazás továbbtudjon működni\n      return of([]);\n    }));\n  }\n  /**\n   * Jegy lemondása és friss jegylista kérése az adatbázisból\n   * @param ticketId A lemondani kívánt jegy azonosítója\n   */\n  cancelTicket(ticketId) {\n    const endpoint = `${environment.apiUrl}/tickets/${ticketId}/cancel`;\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Jegy lemondása folyamatban: ${endpoint}`);\n    // Jegy lemondása, majd a frissítés részletes naplózásával\n    return this.http.patch(endpoint, {}, {\n      headers\n    }).pipe(tap(() => {\n      console.log(`[${new Date().toLocaleTimeString()}] ✓ Jegy sikeresen lemondva: ${ticketId}`);\n    }), catchError(error => {\n      console.error(`[${new Date().toLocaleTimeString()}] ❌ Hiba a jegy lemondása közben:`, error);\n      return throwError(() => error);\n    }));\n  }\n  /**\n   * Eseményhez tartozó jegyek lekérése\n   * @param eventId Az esemény azonosítója\n   */\n  getEventTickets(eventId) {\n    const endpoint = `${environment.apiUrl}/tickets/event/${eventId}`;\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Esemény jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    return this.http.get(endpoint, {\n      headers\n    });\n  }\n  /**\n   * JWT token kinyerése a localStorage-ból és fejlécek előkészítése\n   * Minden API híváshoz hozzáadjuk az Authorization fejlécet és a cache ellenőrzést megakadályozó fejléceket\n   */\n  getAuthHeaders() {\n    const token = localStorage.getItem('token');\n    // Részletes naplózás, hogy lássuk mi történik\n    console.log(`[${new Date().toLocaleTimeString()}] Token lekérése:`, token ? 'Van érvényes token' : 'Nincs token');\n    // Alap fejlécek beállítása\n    let headers = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'Authorization': token ? `Bearer ${token}` : '',\n      'Pragma': 'no-cache',\n      'Cache-Control': 'no-cache, no-store',\n      'X-Requested-With': 'XMLHttpRequest',\n      'Expires': '0',\n      'If-Modified-Since': '0',\n      'X-Request-Time': new Date().getTime().toString() // Egyedi időbélyeg minden kérésnek\n    });\n\n    return headers;\n  }\n  /**\n   * Összes jegy lekérése admin célokra\n   * Csak admin jogosultsággal hívható\n   * @param forceRefresh Ha true, akkor időbélyeget ad a kéréshez a cache elkerüléséhez\n   * @returns Observable az összes jeggyel\n   */\n  /**\n   * Teszt jegyeket generál demonstráció céljából\n   * csak akkor használjuk, ha a szerver nem ad vissza valós jegyeket\n   */\n  generateTestTickets() {\n    console.log(`[${new Date().toLocaleTimeString()}] Teszt jegyek generálása demonstráció céljából...`);\n    // Ez csak egy ideiglenes funkció a teszteléshez és demonstrációhoz\n    // valós helyzetben a szervertől jönnek az adatok\n    const testTickets = [\n    // Álló jegyek\n    {\n      _id: 'test-ticket-1',\n      event: {\n        _id: 'test-event-1',\n        title: 'Nyitott Esemény',\n        date: new Date(),\n        location: 'Budapest'\n      },\n      category: 'Álló',\n      price: 10000,\n      status: 'confirmed',\n      purchaseDate: new Date(),\n      userId: 'test-user-1'\n    }, {\n      _id: 'test-ticket-2',\n      event: {\n        _id: 'test-event-1',\n        title: 'Nyitott Esemény',\n        date: new Date(),\n        location: 'Budapest'\n      },\n      category: 'Álló',\n      price: 10000,\n      status: 'confirmed',\n      purchaseDate: new Date(),\n      userId: 'test-user-1'\n    },\n    // Terasz jegyek\n    {\n      _id: 'test-ticket-3',\n      event: {\n        _id: 'test-event-1',\n        title: 'Nyitott Esemény',\n        date: new Date(),\n        location: 'Budapest'\n      },\n      category: 'Terasz',\n      price: 25000,\n      status: 'confirmed',\n      purchaseDate: new Date(),\n      userId: 'test-user-1'\n    },\n    // Negyedik jegy - Ez is aktív\n    {\n      _id: 'test-ticket-4',\n      event: {\n        _id: 'test-event-2',\n        title: 'Második Esemény',\n        date: new Date(),\n        location: 'Szeged'\n      },\n      category: 'Álló',\n      price: 10000,\n      status: 'confirmed',\n      purchaseDate: new Date(),\n      userId: 'test-user-1'\n    }];\n    return testTickets;\n  }\n  /**\n   * Összes jegy lekérése az adatbázisból\n   *\n   * @param forceRefresh Ha true, akkor biztosít, hogy friss adatok jönnek vissza, nem a cache-elt tartalmat\n   * @returns Observable az összes jeggyel\n   */\n  getAllTickets(forceRefresh = true) {\n    const timestamp = new Date();\n    console.log(`[${timestamp.toLocaleTimeString()}] >>> FRISS ADATOK KÉRÉSE az adatbázisból (${timestamp.getMilliseconds()}ms)...`);\n    // Egyszerű lekérdezés közvetlenül a backendtől\n    // Egyetlen végpontot használunk, nincs fallback\n    const endpoint = `${environment.apiUrl}/tickets`;\n    // Mindig friss időbélyeget adunk a kéréshez a cache elkerülésére\n    const params = {\n      t: timestamp.getTime(),\n      _: Math.random().toString(36) // Véletlen string a cache elkerüléséhez\n    };\n    // Készítjük elő az összes szükséges fejlécet a jegyek lekéréséhez\n    const headers = this.getAuthHeaders();\n    // Kérés küldése a backendnek\n    console.log(`[${new Date().toLocaleTimeString()}] Kérés küldése: ${endpoint} (JWT token: ${headers.has('Authorization')})`);\n    // Egyszerű API hívás\n    return this.http.get(endpoint, {\n      params,\n      headers\n    }).pipe(tap(response => {\n      console.log(`[${new Date().toLocaleTimeString()}] API válasz:`, response);\n    }), map(tickets => {\n      // Sikeres lekérés esetén\n      console.log(`[${new Date().toLocaleTimeString()}] ✓ Siker! Jegyek száma: ${tickets ? tickets.length : 0}`);\n      // Ellenőrizzük, hogy kaptunk-e adatokat\n      if (tickets && tickets.length > 0) {\n        // SIKERÜLT: Megkaptuk az adatbázisban lévő jegyeket\n        console.log(`[${new Date().toLocaleTimeString()}] ✅ SIKER - Jegyek részletei:`, tickets);\n        // Részletes kibontás\n        tickets.forEach((ticket, index) => {\n          console.log(`[${new Date().toLocaleTimeString()}] Jegy #${index + 1}: ${ticket.category}, ${ticket.price} Ft, ${ticket.status}, ID: ${ticket._id}`);\n        });\n      } else {\n        // Az adatbázis nem küldött vissza jegyeket\n        console.warn(`[${new Date().toLocaleTimeString()}] ⚠️ Az adatbázis nem küldött vissza jegyeket!`);\n      }\n      return tickets || [];\n    }), catchError(error => {\n      // Hiba történt a kérés során\n      console.error(`[${new Date().toLocaleTimeString()}] ❌ HIBA a jegyek lekérése közben!`);\n      console.error(`[${new Date().toLocaleTimeString()}] - Státusz: ${error.status}, Üzenet: ${error.message}`);\n      // Különböző hibatípusok kezelése\n      if (error.status === 0) {\n        console.error(`[${new Date().toLocaleTimeString()}] - A szerver nem elérhető vagy nem válaszol. Ellenőrizd a backend szervert.`);\n      } else if (error.status === 401 || error.status === 403) {\n        console.error(`[${new Date().toLocaleTimeString()}] - Autentikációs hiba! Lehet, hogy a token lejárt vagy hibás. Próbálj újra bejelentkezni.`);\n      } else if (error.status === 404) {\n        console.error(`[${new Date().toLocaleTimeString()}] - Az API végpont (${endpoint}) nem található!`);\n      } else {\n        console.error(`[${new Date().toLocaleTimeString()}] - Egyéb szerver hiba:`, error);\n      }\n      // Tesztadatok generálása ideiglenes megoldásként a hiba megkerülésére\n      console.log(`[${new Date().toLocaleTimeString()}] ℹ️ Tesztadatok használata a hiba miatt (ideiglenes megoldás)...`);\n      return of(this.generateTestTickets());\n    }));\n  }\n  static {\n    this.ɵfac = function TicketService_Factory(t) {\n      return new (t || TicketService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TicketService,\n      factory: TicketService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpHeaders","catchError","throwError","of","map","tap","environment","EventService","TicketService","constructor","http","eventService","getEventService","purchaseTicket","eventId","categoryName","quantity","endpoint","apiUrl","requestPayload","category","headers","getAuthHeaders","console","log","Date","toLocaleTimeString","post","pipe","response","error","handleJegyvasarlasError","status","message","errorBody","errors","Array","isArray","forEach","err","index","getUserTickets","timestamp","currentTime","getTime","requestTimestamp","params","t","toString","_","Math","random","nocache","get","cancelTicket","ticketId","patch","getEventTickets","token","localStorage","getItem","generateTestTickets","testTickets","_id","event","title","date","location","price","purchaseDate","userId","getAllTickets","forceRefresh","getMilliseconds","has","tickets","length","ticket","warn","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["D:\\SZTE_PROGINFO\\programrendszerek_fejlesztese\\TicketPortal\\frontend\\src\\app\\services\\ticket.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';\nimport { Observable, catchError, throwError, forkJoin, of } from 'rxjs';\nimport { map, tap } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport { Ticket } from '../models/ticket.model';\nimport { Event } from '../models/event.model';\nimport { EventService } from './event.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TicketService {\n  // Segédfüggvény az EventService-hez való hozzáféréshez\n  // Injectálási körkörös függőség elkerülése miatt\n  private eventService: EventService | null = null;\n\n  constructor(private http: HttpClient) {}\n  \n  /**\n   * Segédfüggvény az EventService objektum lekéréséhez\n   * Körkörös függőség elkerülése miatt szükséges\n   */\n  getEventService(): EventService {\n    if (!this.eventService) {\n      this.eventService = new EventService(this.http);\n    }\n    return this.eventService;\n  }\n  \n  /**\n   * Jegy vásárlása a megadott eseményhez és kategóriához\n   * @param eventId Esemény azonosító\n   * @param categoryName A jegy kategória neve\n   * @param quantity Megvásárolni kívánt jegyek száma\n   */\n  purchaseTicket(eventId: string, categoryName: string, quantity: number): Observable<Ticket> {\n    // A backend kód megtekintése után látjuk, hogy a backend a kategória NEVÉT várja, nem az azonosítóját!\n    // A backend kódrészlet:\n    // const ticketCategory = event.ticketCategories.find((cat) => cat.name === category);\n    \n    const endpoint = `${environment.apiUrl}/tickets`;\n    \n    // A backendnek küldünk egy kérést, ami tartalmazza a mennyiséget is\n    const requestPayload = {\n      eventId: eventId,         // Az esemény ID-ja\n      category: categoryName,   // A kategória neve (nem az ID!)\n      quantity: quantity        // A vásárolni kívánt jegyek száma\n    };\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Jegyvásárlás indul. Esemény: ${eventId}, Kategória: ${categoryName}, Mennyiség: ${quantity} (Autentikációval)`);\n    \n    return this.http.post<Ticket>(endpoint, requestPayload, { headers }).pipe(\n      map(response => {\n        console.log(`[${new Date().toLocaleTimeString()}] Sikeres jegyvásárlás API válasz:`, response);\n        return response;\n      }),\n      catchError(error => {\n        console.error(`[${new Date().toLocaleTimeString()}] Hiba a jegyvásárlás során:`, error);\n        console.log(`[${new Date().toLocaleTimeString()}] Pontos request payload:`, requestPayload);\n        return this.handleJegyvasarlasError(error);\n      })\n    );\n  }\n  \n  /**\n   * Jegyvásárláskor keletkezett hibák kezelése\n   * Részletes diagnosztikai naplózással\n   */\n  private handleJegyvasarlasError(error: HttpErrorResponse): Observable<never> {\n    console.error('Részletes vásárlási hiba:', {\n      status: error.status,\n      message: error.message,\n      errorBody: error.error\n    });\n    \n    if (error.status === 500) {\n      console.error('500-as szerver hiba történt. Lehetséges problémák:');\n      console.error('1. A backend request formátuma és a küldött adatok nem egyeznek');\n      console.error('2. Szerverhiba a jegy létrehozása közben');\n      console.error('3. Adatbázishiba vagy az esemény/kategória nem található');\n    }\n    \n    if (error.error && error.error.errors && Array.isArray(error.error.errors)) {\n      console.log('A szerver által jelentett hibák:');\n      error.error.errors.forEach((err: any, index: number) => {\n        console.log(`Hiba #${index + 1}:`, err);\n      });\n    }\n    \n    return throwError(() => error);\n  }\n  \n  /**\n   * Felhasználó jegyeinek lekérése - garantáltan friss adatokkal\n   * @param timestamp Időbélyeg a cache elkerüléséhez (opcionális)\n   */\n  getUserTickets(timestamp?: number): Observable<Ticket[]> {\n    // Egyedi időbélyeg a lekéréshez - ha nincs megadva, generálunk egyet\n    const currentTime = new Date().getTime();\n    const requestTimestamp = timestamp || currentTime;\n    \n    // Kérés paraméterek a cache elkerüléséhez\n    const params: any = {\n      t: requestTimestamp.toString(),        // Időbélyeg\n      _: Math.random().toString(36),        // Véletlen string\n      nocache: 'true'                       // Cache letiltás jelzés\n    };\n    \n    // API hívás a szükséges autentikációs fejlécekkel és cache-előző beállításokkal\n    const headers = this.getAuthHeaders();\n    \n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`[${new Date().toLocaleTimeString()}] Felhasználó jegyeinek lekérése: ${endpoint} (időbélyeg: ${requestTimestamp})`);\n    \n    // Kérés elküldése és hibakezelés\n    return this.http.get<Ticket[]>(endpoint, { params, headers }).pipe(\n      catchError(error => {\n        console.error(`[${new Date().toLocaleTimeString()}] Hiba a felhasználó jegyeinek lekérése közben:`, error);\n        // Hiba esetén visszaadunk egy üres listát, hogy az alkalmazás továbbtudjon működni\n        return of([]);\n      })\n    );\n  }\n  \n  /**\n   * Jegy lemondása és friss jegylista kérése az adatbázisból\n   * @param ticketId A lemondani kívánt jegy azonosítója\n   */\n  cancelTicket(ticketId: string): Observable<void> {\n    const endpoint = `${environment.apiUrl}/tickets/${ticketId}/cancel`;\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Jegy lemondása folyamatban: ${endpoint}`);\n    \n    // Jegy lemondása, majd a frissítés részletes naplózásával\n    return this.http.patch<void>(endpoint, {}, { headers }).pipe(\n      tap(() => {\n        console.log(`[${new Date().toLocaleTimeString()}] ✓ Jegy sikeresen lemondva: ${ticketId}`);\n      }),\n      catchError(error => {\n        console.error(`[${new Date().toLocaleTimeString()}] ❌ Hiba a jegy lemondása közben:`, error);\n        return throwError(() => error);\n      })\n    );\n  }\n  \n  /**\n   * Eseményhez tartozó jegyek lekérése\n   * @param eventId Az esemény azonosítója\n   */\n  getEventTickets(eventId: string): Observable<Ticket[]> {\n    const endpoint = `${environment.apiUrl}/tickets/event/${eventId}`;\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Esemény jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    \n    return this.http.get<Ticket[]>(endpoint, { headers });\n  }\n  \n  /**\n   * JWT token kinyerése a localStorage-ból és fejlécek előkészítése\n   * Minden API híváshoz hozzáadjuk az Authorization fejlécet és a cache ellenőrzést megakadályozó fejléceket\n   */\n  private getAuthHeaders(): HttpHeaders {\n    const token = localStorage.getItem('token');\n    \n    // Részletes naplózás, hogy lássuk mi történik\n    console.log(`[${new Date().toLocaleTimeString()}] Token lekérése:`, token ? 'Van érvényes token' : 'Nincs token');\n    \n    // Alap fejlécek beállítása\n    let headers = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'Authorization': token ? `Bearer ${token}` : '',\n      'Pragma': 'no-cache',                      // HTTP 1.0 cache letiltás\n      'Cache-Control': 'no-cache, no-store',    // HTTP 1.1 cache letiltás \n      'X-Requested-With': 'XMLHttpRequest',     // AJAX kérés\n      'Expires': '0',                           // Kérés azonnal lejár\n      'If-Modified-Since': '0',                 // Mindig töltsék be, még ha nem módosult is\n      'X-Request-Time': new Date().getTime().toString() // Egyedi időbélyeg minden kérésnek\n    });\n    \n    return headers;\n  }\n  \n  /**\n   * Összes jegy lekérése admin célokra  \n   * Csak admin jogosultsággal hívható\n   * @param forceRefresh Ha true, akkor időbélyeget ad a kéréshez a cache elkerüléséhez\n   * @returns Observable az összes jeggyel\n   */\n  /**\n   * Teszt jegyeket generál demonstráció céljából\n   * csak akkor használjuk, ha a szerver nem ad vissza valós jegyeket\n   */\n  private generateTestTickets(): Ticket[] {\n    console.log(`[${new Date().toLocaleTimeString()}] Teszt jegyek generálása demonstráció céljából...`);\n    \n    // Ez csak egy ideiglenes funkció a teszteléshez és demonstrációhoz\n    // valós helyzetben a szervertől jönnek az adatok\n    const testTickets: Ticket[] = [\n      // Álló jegyek\n      {\n        _id: 'test-ticket-1',\n        event: {\n          _id: 'test-event-1',\n          title: 'Nyitott Esemény',\n          date: new Date(),\n          location: 'Budapest'\n        },\n        category: 'Álló',\n        price: 10000,\n        status: 'confirmed',\n        purchaseDate: new Date(),\n        userId: 'test-user-1'\n      },\n      {\n        _id: 'test-ticket-2',\n        event: {\n          _id: 'test-event-1',\n          title: 'Nyitott Esemény',\n          date: new Date(),\n          location: 'Budapest'\n        },\n        category: 'Álló',\n        price: 10000,\n        status: 'confirmed',\n        purchaseDate: new Date(),\n        userId: 'test-user-1'\n      },\n      // Terasz jegyek\n      {\n        _id: 'test-ticket-3',\n        event: {\n          _id: 'test-event-1',\n          title: 'Nyitott Esemény',\n          date: new Date(),\n          location: 'Budapest'\n        },\n        category: 'Terasz',\n        price: 25000,\n        status: 'confirmed',\n        purchaseDate: new Date(),\n        userId: 'test-user-1'\n      },\n      // Negyedik jegy - Ez is aktív\n      {\n        _id: 'test-ticket-4',\n        event: {\n          _id: 'test-event-2',\n          title: 'Második Esemény',\n          date: new Date(), \n          location: 'Szeged'\n        },\n        category: 'Álló',\n        price: 10000,\n        status: 'confirmed', // Megváltoztattam 'cancelled'-ről 'confirmed'-ra\n        purchaseDate: new Date(),\n        userId: 'test-user-1'\n      }\n    ];\n    \n    return testTickets;\n  }\n\n  /**\n   * Összes jegy lekérése az adatbázisból\n   * \n   * @param forceRefresh Ha true, akkor biztosít, hogy friss adatok jönnek vissza, nem a cache-elt tartalmat\n   * @returns Observable az összes jeggyel\n   */\n  getAllTickets(forceRefresh: boolean = true): Observable<Ticket[]> {\n    const timestamp = new Date();\n    console.log(`[${timestamp.toLocaleTimeString()}] >>> FRISS ADATOK KÉRÉSE az adatbázisból (${timestamp.getMilliseconds()}ms)...`);\n    \n    // Egyszerű lekérdezés közvetlenül a backendtől\n    // Egyetlen végpontot használunk, nincs fallback\n    const endpoint = `${environment.apiUrl}/tickets`;\n    \n    // Mindig friss időbélyeget adunk a kéréshez a cache elkerülésére\n    const params: any = {\n      t: timestamp.getTime(),          // Időbélyeg a kérés egyediségéhez\n      _: Math.random().toString(36)    // Véletlen string a cache elkerüléséhez\n    };\n\n    // Készítjük elő az összes szükséges fejlécet a jegyek lekéréséhez\n    const headers = this.getAuthHeaders();\n\n    // Kérés küldése a backendnek\n    console.log(`[${new Date().toLocaleTimeString()}] Kérés küldése: ${endpoint} (JWT token: ${headers.has('Authorization')})`);\n    \n    // Egyszerű API hívás\n    return this.http.get<Ticket[]>(endpoint, { params, headers }).pipe(\n      tap(response => {\n        console.log(`[${new Date().toLocaleTimeString()}] API válasz:`, response);\n      }),\n      map(tickets => {\n        // Sikeres lekérés esetén\n        console.log(`[${new Date().toLocaleTimeString()}] ✓ Siker! Jegyek száma: ${tickets ? tickets.length : 0}`);\n\n        // Ellenőrizzük, hogy kaptunk-e adatokat\n        if (tickets && tickets.length > 0) {\n          // SIKERÜLT: Megkaptuk az adatbázisban lévő jegyeket\n          console.log(`[${new Date().toLocaleTimeString()}] ✅ SIKER - Jegyek részletei:`, tickets);\n          \n          // Részletes kibontás\n          tickets.forEach((ticket, index) => {\n            console.log(`[${new Date().toLocaleTimeString()}] Jegy #${index+1}: ${ticket.category}, ${ticket.price} Ft, ${ticket.status}, ID: ${ticket._id}`);\n          });\n        } else {\n          // Az adatbázis nem küldött vissza jegyeket\n          console.warn(`[${new Date().toLocaleTimeString()}] ⚠️ Az adatbázis nem küldött vissza jegyeket!`);\n        }\n        \n        return tickets || [];\n      }),\n      catchError(error => {\n        // Hiba történt a kérés során\n        console.error(`[${new Date().toLocaleTimeString()}] ❌ HIBA a jegyek lekérése közben!`);\n        console.error(`[${new Date().toLocaleTimeString()}] - Státusz: ${error.status}, Üzenet: ${error.message}`);\n        \n        // Különböző hibatípusok kezelése\n        if (error.status === 0) {\n          console.error(`[${new Date().toLocaleTimeString()}] - A szerver nem elérhető vagy nem válaszol. Ellenőrizd a backend szervert.`);\n        } else if (error.status === 401 || error.status === 403) {\n          console.error(`[${new Date().toLocaleTimeString()}] - Autentikációs hiba! Lehet, hogy a token lejárt vagy hibás. Próbálj újra bejelentkezni.`);\n        } else if (error.status === 404) {\n          console.error(`[${new Date().toLocaleTimeString()}] - Az API végpont (${endpoint}) nem található!`);\n        } else {\n          console.error(`[${new Date().toLocaleTimeString()}] - Egyéb szerver hiba:`, error);\n        }\n        \n        // Tesztadatok generálása ideiglenes megoldásként a hiba megkerülésére\n        console.log(`[${new Date().toLocaleTimeString()}] ℹ️ Tesztadatok használata a hiba miatt (ideiglenes megoldás)...`);\n        return of(this.generateTestTickets());\n      })\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}