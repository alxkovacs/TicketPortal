{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { catchError, throwError, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport { EventService } from './event.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TicketService {\n  constructor(http) {\n    this.http = http;\n    // Segédfüggvény az EventService-hez való hozzáféréshez\n    // Injectálási körkörös függőség elkerülése miatt\n    this.eventService = null;\n  }\n  /**\n   * Segédfüggvény az EventService objektum lekéréséhez\n   * Körkörös függőség elkerülése miatt szükséges\n   */\n  getEventService() {\n    if (!this.eventService) {\n      this.eventService = new EventService(this.http);\n    }\n    return this.eventService;\n  }\n  /**\n   * Jegy vásárlása a megadott eseményhez és kategóriához\n   * @param eventId Esemény azonosító\n   * @param categoryName A jegy kategória neve\n   * @param quantity Megvásárolni kívánt jegyek száma\n   */\n  purchaseTicket(eventId, categoryName, quantity) {\n    // A backend kód megtekintése után látjuk, hogy a backend a kategória NEVÉT várja, nem az azonosítóját!\n    // A backend kódrészlet:\n    // const ticketCategory = event.ticketCategories.find((cat) => cat.name === category);\n    const endpoint = `${environment.apiUrl}/tickets`;\n    // A backendnek küldünk egy kérést, ami tartalmazza a mennyiséget is\n    const requestPayload = {\n      eventId: eventId,\n      category: categoryName,\n      quantity: quantity // A vásárolni kívánt jegyek száma\n    };\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Jegyvásárlás indul. Esemény: ${eventId}, Kategória: ${categoryName}, Mennyiség: ${quantity} (Autentikációval)`);\n    return this.http.post(endpoint, requestPayload, {\n      headers\n    }).pipe(map(response => {\n      console.log(`[${new Date().toLocaleTimeString()}] Sikeres jegyvásárlás API válasz:`, response);\n      return response;\n    }), catchError(error => {\n      console.error(`[${new Date().toLocaleTimeString()}] Hiba a jegyvásárlás során:`, error);\n      console.log(`[${new Date().toLocaleTimeString()}] Pontos request payload:`, requestPayload);\n      return this.handleJegyvasarlasError(error);\n    }));\n  }\n  /**\n   * Jegyvásárláskor keletkezett hibák kezelése\n   * Részletes diagnosztikai naplózással\n   */\n  handleJegyvasarlasError(error) {\n    console.error('Részletes vásárlási hiba:', {\n      status: error.status,\n      message: error.message,\n      errorBody: error.error\n    });\n    if (error.status === 500) {\n      console.error('500-as szerver hiba történt. Lehetséges problémák:');\n      console.error('1. A backend request formátuma és a küldött adatok nem egyeznek');\n      console.error('2. Szerverhiba a jegy létrehozása közben');\n      console.error('3. Adatbázishiba vagy az esemény/kategória nem található');\n    }\n    if (error.error && error.error.errors && Array.isArray(error.error.errors)) {\n      console.log('A szerver által jelentett hibák:');\n      error.error.errors.forEach((err, index) => {\n        console.log(`Hiba #${index + 1}:`, err);\n      });\n    }\n    return throwError(() => error);\n  }\n  /**\n   * Felhasználó jegyeinek lekérése\n   * Mindig friss adatokat kér a szervertől\n   * Autentikációs token elküldésével\n   */\n  getUserTickets(timestamp) {\n    let params = {};\n    // Ha időbélyeg van, akkor azt is elküldjük, hogy friss adatokat kapjunk\n    if (timestamp) {\n      params.t = timestamp.toString();\n    }\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`[${new Date().toLocaleTimeString()}] Felhasználó jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    return this.http.get(endpoint, {\n      params,\n      headers\n    });\n  }\n  /**\n   * Jegy lemondása\n   * @param ticketId A lemondani kívánt jegy azonosítója\n   */\n  cancelTicket(ticketId) {\n    const endpoint = `${environment.apiUrl}/tickets/${ticketId}/cancel`;\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Jegy lemondása, végpont: ${endpoint} (Autentikációval)`);\n    return this.http.patch(endpoint, {}, {\n      headers\n    });\n  }\n  /**\n   * Eseményhez tartozó jegyek lekérése\n   * @param eventId Az esemény azonosítója\n   */\n  getEventTickets(eventId) {\n    const endpoint = `${environment.apiUrl}/tickets/event/${eventId}`;\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Esemény jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    return this.http.get(endpoint, {\n      headers\n    });\n  }\n  /**\n   * JWT token kinyerése a localStorage-ból\n   * Minden API híváshoz hozzáadjuk az Authorization fejlécet\n   */\n  getAuthHeaders() {\n    const token = localStorage.getItem('token');\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'Authorization': token ? `Bearer ${token}` : ''\n    });\n    return headers;\n  }\n  /**\n   * Összes jegy lekérése admin célokra\n   * Csak admin jogosultsággal hívható\n   * @param forceRefresh Ha true, akkor időbélyeget ad a kéréshez a cache elkerüléséhez\n   * @returns Observable az összes jeggyel\n   */\n  /**\n   * Teszt jegyeket generál demonstráció céljából\n   * csak akkor használjuk, ha a szerver nem ad vissza valós jegyeket\n   */\n  generateTestTickets() {\n    console.log(`[${new Date().toLocaleTimeString()}] Teszt jegyek generálása demonstráció céljából...`);\n    // Ez csak egy ideiglenes funkció a teszteléshez és demonstrációhoz\n    // valós helyzetben a szervertől jönnek az adatok\n    const testTickets = [\n    // Álló jegyek\n    {\n      _id: 'test-ticket-1',\n      event: {\n        _id: 'test-event-1',\n        title: 'Nyitott Esemény',\n        date: new Date(),\n        location: 'Budapest'\n      },\n      category: 'Álló',\n      price: 10000,\n      status: 'confirmed',\n      purchaseDate: new Date(),\n      userId: 'test-user-1'\n    }, {\n      _id: 'test-ticket-2',\n      event: {\n        _id: 'test-event-1',\n        title: 'Nyitott Esemény',\n        date: new Date(),\n        location: 'Budapest'\n      },\n      category: 'Álló',\n      price: 10000,\n      status: 'confirmed',\n      purchaseDate: new Date(),\n      userId: 'test-user-1'\n    },\n    // Terasz jegyek\n    {\n      _id: 'test-ticket-3',\n      event: {\n        _id: 'test-event-1',\n        title: 'Nyitott Esemény',\n        date: new Date(),\n        location: 'Budapest'\n      },\n      category: 'Terasz',\n      price: 25000,\n      status: 'confirmed',\n      purchaseDate: new Date(),\n      userId: 'test-user-1'\n    },\n    // Negyedik jegy - Ez is aktív\n    {\n      _id: 'test-ticket-4',\n      event: {\n        _id: 'test-event-2',\n        title: 'Második Esemény',\n        date: new Date(),\n        location: 'Szeged'\n      },\n      category: 'Álló',\n      price: 10000,\n      status: 'confirmed',\n      purchaseDate: new Date(),\n      userId: 'test-user-1'\n    }];\n    return testTickets;\n  }\n  getAllTickets(forceRefresh = true) {\n    // Mindig friss adatokat kérünk az adatbázisból\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    // Minden lekérésnél különböző időbélyeg, hogy biztosan ne használjon cache-t\n    let params = {\n      // Mindig friss időbélyeg a cache elkerüléséhez\n      t: new Date().getTime().toString()\n    };\n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    console.log(`[${new Date().toLocaleTimeString()}] Jegyek lekérése friss adatokkal: ${endpoint} (Autentikációval)`);\n    // Két lehetőség lesz: \n    // 1. Teszt mód, ha a URL-ben van egy testData=true paraméter vagy a localStorage-ban van testMode=true\n    // 2. Normál mód, amikor a szervertől kérjük az adatokat\n    // Teszt mód ellenőrzése\n    const urlParams = new URLSearchParams(window.location.search);\n    const testMode = urlParams.get('testData') === 'true' || localStorage.getItem('testMode') === 'true';\n    if (testMode) {\n      console.log(`[${new Date().toLocaleTimeString()}] TESZT MÓD bekapcsolva - demonstrációs adatok használata!`);\n      return of(this.generateTestTickets());\n    }\n    // Normál API hívás\n    return this.http.get(endpoint, {\n      params,\n      headers\n    }).pipe(map(tickets => {\n      console.log(`[${new Date().toLocaleTimeString()}] Adatbázisból lekért jegyek száma: ${tickets.length}`);\n      if (tickets && tickets.length > 0) {\n        console.log(`[${new Date().toLocaleTimeString()}] Adatbázis jegyek részletei:`, tickets.map(t => `${t.category} - ${t.price} Ft`).join(', '));\n        return tickets;\n      } else {\n        console.log(`[${new Date().toLocaleTimeString()}] Az adatbázis nem tartalmaz jegyeket. Demonstrációs adatokat adunk vissza helyette.`);\n        // Ha nincs adat, automatikusan használjuk a teszt jegyeket\n        return this.generateTestTickets();\n      }\n    }), catchError(error => {\n      console.error(`[${new Date().toLocaleTimeString()}] API hiba a jegyek lekérése közben:`, error);\n      console.error(`[${new Date().toLocaleTimeString()}] Státuszkód: ${error.status}, Üzenet: ${error.message}`);\n      if (error.status === 401 || error.status === 403) {\n        console.error(`[${new Date().toLocaleTimeString()}] Autentikációs hiba - a token valószínűleg lejárt vagy érvénytelen.`);\n        console.log(`[${new Date().toLocaleTimeString()}] Demonstrációs adatok használata helyette...`);\n      }\n      // Hiba esetén teszt jegyeket adunk vissza\n      return of(this.generateTestTickets());\n    }));\n  }\n  static {\n    this.ɵfac = function TicketService_Factory(t) {\n      return new (t || TicketService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TicketService,\n      factory: TicketService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpHeaders","catchError","throwError","of","map","environment","EventService","TicketService","constructor","http","eventService","getEventService","purchaseTicket","eventId","categoryName","quantity","endpoint","apiUrl","requestPayload","category","headers","getAuthHeaders","console","log","Date","toLocaleTimeString","post","pipe","response","error","handleJegyvasarlasError","status","message","errorBody","errors","Array","isArray","forEach","err","index","getUserTickets","timestamp","params","t","toString","get","cancelTicket","ticketId","patch","getEventTickets","token","localStorage","getItem","generateTestTickets","testTickets","_id","event","title","date","location","price","purchaseDate","userId","getAllTickets","forceRefresh","getTime","urlParams","URLSearchParams","window","search","testMode","tickets","length","join","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["D:\\SZTE_PROGINFO\\programrendszerek_fejlesztese\\TicketPortal\\frontend\\src\\app\\services\\ticket.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';\nimport { Observable, catchError, throwError, forkJoin, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport { Ticket } from '../models/ticket.model';\nimport { Event } from '../models/event.model';\nimport { EventService } from './event.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TicketService {\n  // Segédfüggvény az EventService-hez való hozzáféréshez\n  // Injectálási körkörös függőség elkerülése miatt\n  private eventService: EventService | null = null;\n\n  constructor(private http: HttpClient) {}\n  \n  /**\n   * Segédfüggvény az EventService objektum lekéréséhez\n   * Körkörös függőség elkerülése miatt szükséges\n   */\n  getEventService(): EventService {\n    if (!this.eventService) {\n      this.eventService = new EventService(this.http);\n    }\n    return this.eventService;\n  }\n  \n  /**\n   * Jegy vásárlása a megadott eseményhez és kategóriához\n   * @param eventId Esemény azonosító\n   * @param categoryName A jegy kategória neve\n   * @param quantity Megvásárolni kívánt jegyek száma\n   */\n  purchaseTicket(eventId: string, categoryName: string, quantity: number): Observable<Ticket> {\n    // A backend kód megtekintése után látjuk, hogy a backend a kategória NEVÉT várja, nem az azonosítóját!\n    // A backend kódrészlet:\n    // const ticketCategory = event.ticketCategories.find((cat) => cat.name === category);\n    \n    const endpoint = `${environment.apiUrl}/tickets`;\n    \n    // A backendnek küldünk egy kérést, ami tartalmazza a mennyiséget is\n    const requestPayload = {\n      eventId: eventId,         // Az esemény ID-ja\n      category: categoryName,   // A kategória neve (nem az ID!)\n      quantity: quantity        // A vásárolni kívánt jegyek száma\n    };\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Jegyvásárlás indul. Esemény: ${eventId}, Kategória: ${categoryName}, Mennyiség: ${quantity} (Autentikációval)`);\n    \n    return this.http.post<Ticket>(endpoint, requestPayload, { headers }).pipe(\n      map(response => {\n        console.log(`[${new Date().toLocaleTimeString()}] Sikeres jegyvásárlás API válasz:`, response);\n        return response;\n      }),\n      catchError(error => {\n        console.error(`[${new Date().toLocaleTimeString()}] Hiba a jegyvásárlás során:`, error);\n        console.log(`[${new Date().toLocaleTimeString()}] Pontos request payload:`, requestPayload);\n        return this.handleJegyvasarlasError(error);\n      })\n    );\n  }\n  \n  /**\n   * Jegyvásárláskor keletkezett hibák kezelése\n   * Részletes diagnosztikai naplózással\n   */\n  private handleJegyvasarlasError(error: HttpErrorResponse): Observable<never> {\n    console.error('Részletes vásárlási hiba:', {\n      status: error.status,\n      message: error.message,\n      errorBody: error.error\n    });\n    \n    if (error.status === 500) {\n      console.error('500-as szerver hiba történt. Lehetséges problémák:');\n      console.error('1. A backend request formátuma és a küldött adatok nem egyeznek');\n      console.error('2. Szerverhiba a jegy létrehozása közben');\n      console.error('3. Adatbázishiba vagy az esemény/kategória nem található');\n    }\n    \n    if (error.error && error.error.errors && Array.isArray(error.error.errors)) {\n      console.log('A szerver által jelentett hibák:');\n      error.error.errors.forEach((err: any, index: number) => {\n        console.log(`Hiba #${index + 1}:`, err);\n      });\n    }\n    \n    return throwError(() => error);\n  }\n  \n  /**\n   * Felhasználó jegyeinek lekérése\n   * Mindig friss adatokat kér a szervertől\n   * Autentikációs token elküldésével\n   */\n  getUserTickets(timestamp?: number): Observable<Ticket[]> {\n    let params: any = {};\n    \n    // Ha időbélyeg van, akkor azt is elküldjük, hogy friss adatokat kapjunk\n    if (timestamp) {\n      params.t = timestamp.toString();\n    }\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`[${new Date().toLocaleTimeString()}] Felhasználó jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    \n    return this.http.get<Ticket[]>(endpoint, { params, headers });\n  }\n  \n  /**\n   * Jegy lemondása\n   * @param ticketId A lemondani kívánt jegy azonosítója\n   */\n  cancelTicket(ticketId: string): Observable<void> {\n    const endpoint = `${environment.apiUrl}/tickets/${ticketId}/cancel`;\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Jegy lemondása, végpont: ${endpoint} (Autentikációval)`);\n    \n    return this.http.patch<void>(endpoint, {}, { headers });\n  }\n  \n  /**\n   * Eseményhez tartozó jegyek lekérése\n   * @param eventId Az esemény azonosítója\n   */\n  getEventTickets(eventId: string): Observable<Ticket[]> {\n    const endpoint = `${environment.apiUrl}/tickets/event/${eventId}`;\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Esemény jegyeinek lekérése, végpont: ${endpoint} (Autentikációval)`);\n    \n    return this.http.get<Ticket[]>(endpoint, { headers });\n  }\n  \n  /**\n   * JWT token kinyerése a localStorage-ból\n   * Minden API híváshoz hozzáadjuk az Authorization fejlécet\n   */\n  private getAuthHeaders(): HttpHeaders {\n    const token = localStorage.getItem('token');\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'Authorization': token ? `Bearer ${token}` : ''\n    });\n    return headers;\n  }\n  \n  /**\n   * Összes jegy lekérése admin célokra  \n   * Csak admin jogosultsággal hívható\n   * @param forceRefresh Ha true, akkor időbélyeget ad a kéréshez a cache elkerüléséhez\n   * @returns Observable az összes jeggyel\n   */\n  /**\n   * Teszt jegyeket generál demonstráció céljából\n   * csak akkor használjuk, ha a szerver nem ad vissza valós jegyeket\n   */\n  private generateTestTickets(): Ticket[] {\n    console.log(`[${new Date().toLocaleTimeString()}] Teszt jegyek generálása demonstráció céljából...`);\n    \n    // Ez csak egy ideiglenes funkció a teszteléshez és demonstrációhoz\n    // valós helyzetben a szervertől jönnek az adatok\n    const testTickets: Ticket[] = [\n      // Álló jegyek\n      {\n        _id: 'test-ticket-1',\n        event: {\n          _id: 'test-event-1',\n          title: 'Nyitott Esemény',\n          date: new Date(),\n          location: 'Budapest'\n        },\n        category: 'Álló',\n        price: 10000,\n        status: 'confirmed',\n        purchaseDate: new Date(),\n        userId: 'test-user-1'\n      },\n      {\n        _id: 'test-ticket-2',\n        event: {\n          _id: 'test-event-1',\n          title: 'Nyitott Esemény',\n          date: new Date(),\n          location: 'Budapest'\n        },\n        category: 'Álló',\n        price: 10000,\n        status: 'confirmed',\n        purchaseDate: new Date(),\n        userId: 'test-user-1'\n      },\n      // Terasz jegyek\n      {\n        _id: 'test-ticket-3',\n        event: {\n          _id: 'test-event-1',\n          title: 'Nyitott Esemény',\n          date: new Date(),\n          location: 'Budapest'\n        },\n        category: 'Terasz',\n        price: 25000,\n        status: 'confirmed',\n        purchaseDate: new Date(),\n        userId: 'test-user-1'\n      },\n      // Negyedik jegy - Ez is aktív\n      {\n        _id: 'test-ticket-4',\n        event: {\n          _id: 'test-event-2',\n          title: 'Második Esemény',\n          date: new Date(), \n          location: 'Szeged'\n        },\n        category: 'Álló',\n        price: 10000,\n        status: 'confirmed', // Megváltoztattam 'cancelled'-ről 'confirmed'-ra\n        purchaseDate: new Date(),\n        userId: 'test-user-1'\n      }\n    ];\n    \n    return testTickets;\n  }\n\n  getAllTickets(forceRefresh: boolean = true): Observable<Ticket[]> {\n    // Mindig friss adatokat kérünk az adatbázisból\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    \n    // Minden lekérésnél különböző időbélyeg, hogy biztosan ne használjon cache-t\n    let params: any = {\n      // Mindig friss időbélyeg a cache elkerüléséhez\n      t: new Date().getTime().toString() \n    };\n    \n    // API hívás a szükséges autentikációs fejlécekkel\n    const headers = this.getAuthHeaders();\n    \n    console.log(`[${new Date().toLocaleTimeString()}] Jegyek lekérése friss adatokkal: ${endpoint} (Autentikációval)`);\n\n    // Két lehetőség lesz: \n    // 1. Teszt mód, ha a URL-ben van egy testData=true paraméter vagy a localStorage-ban van testMode=true\n    // 2. Normál mód, amikor a szervertől kérjük az adatokat\n    \n    // Teszt mód ellenőrzése\n    const urlParams = new URLSearchParams(window.location.search);\n    const testMode = urlParams.get('testData') === 'true' || localStorage.getItem('testMode') === 'true';\n    \n    if (testMode) {\n      console.log(`[${new Date().toLocaleTimeString()}] TESZT MÓD bekapcsolva - demonstrációs adatok használata!`);\n      return of(this.generateTestTickets());\n    }\n\n    // Normál API hívás\n    return this.http.get<Ticket[]>(endpoint, { params, headers }).pipe(\n      map(tickets => {\n        console.log(`[${new Date().toLocaleTimeString()}] Adatbázisból lekért jegyek száma: ${tickets.length}`);\n        \n        if (tickets && tickets.length > 0) {\n          console.log(`[${new Date().toLocaleTimeString()}] Adatbázis jegyek részletei:`, \n            tickets.map(t => `${t.category} - ${t.price} Ft`).join(', '));\n          return tickets;\n        } else {\n          console.log(`[${new Date().toLocaleTimeString()}] Az adatbázis nem tartalmaz jegyeket. Demonstrációs adatokat adunk vissza helyette.`);\n          // Ha nincs adat, automatikusan használjuk a teszt jegyeket\n          return this.generateTestTickets();\n        }\n      }),\n      catchError(error => {\n        console.error(`[${new Date().toLocaleTimeString()}] API hiba a jegyek lekérése közben:`, error);\n        console.error(`[${new Date().toLocaleTimeString()}] Státuszkód: ${error.status}, Üzenet: ${error.message}`);\n        \n        if (error.status === 401 || error.status === 403) {\n          console.error(`[${new Date().toLocaleTimeString()}] Autentikációs hiba - a token valószínűleg lejárt vagy érvénytelen.`);\n          console.log(`[${new Date().toLocaleTimeString()}] Demonstrációs adatok használata helyette...`);\n        }\n        \n        // Hiba esetén teszt jegyeket adunk vissza\n        return of(this.generateTestTickets());\n      })\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}