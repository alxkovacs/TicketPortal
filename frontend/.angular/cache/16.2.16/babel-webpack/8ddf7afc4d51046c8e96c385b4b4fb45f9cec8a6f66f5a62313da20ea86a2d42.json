{"ast":null,"code":"import { catchError, throwError, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport { EventService } from './event.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TicketService {\n  constructor(http) {\n    this.http = http;\n    // Követjük a vásárolt jegyeket kategóriával és árral együtt\n    this.purchasedTickets = [];\n    // Ismert jegykategóriák és áraik, ahogy a felhasználó megadta\n    this.knownCategories = {\n      'Álló': 10000,\n      'Terasz': 25000\n    };\n    // Segédfüggvény az EventService-hez való hozzáféréshez\n    // Injectálási körkörös függőség elkerülése miatt\n    this.eventService = null;\n    // Követjük a vásárolt jegyeket kategóriával és árral együtt\n    this.purchasedTickets = [];\n    // Ismert jegykategóriák és áraik, ahogy a felhasználó megadta\n    this.knownCategories = {\n      'Álló': 10000,\n      'Terasz': 25000\n    };\n    // Segédfüggvény az EventService-hez való hozzáféréshez\n    // Injectálási körkörös függőség elkerülése miatt\n    this.eventService = null;\n    // Inicializáljuk a lokális jegy tárolót\n    this.initializeFromLocalStorage();\n  }\n  /**\n   * Jegy vásárlása a megadott eseményhez és kategóriához\n   * @param eventId Esemény azonosító\n   * @param categoryName A jegy kategória neve\n   * @param quantity Megvásárolni kívánt jegyek száma\n   */\n  purchaseTicket(eventId, categoryName, quantity) {\n    // A backend kód megtekintése után látjuk, hogy a backend a kategória NEVÉT várja, nem az azonosítóját!\n    // A backend kódrészlet:\n    // const ticketCategory = event.ticketCategories.find((cat) => cat.name === category);\n    const endpoint = `${environment.apiUrl}/tickets`;\n    // A backendnek küldünk egy kérést, ami tartalmazza a mennyiséget is\n    const requestPayload = {\n      eventId: eventId,\n      category: categoryName,\n      quantity: quantity // A vásárolni kívánt jegyek száma\n    };\n\n    console.log(`Jegyvásárlás indul. Esemény: ${eventId}, Kategória: ${categoryName}, Mennyiség: ${quantity}`);\n    // Meghatározzuk a jegy árát a kategória alapján\n    const price = this.knownCategories[categoryName] || 10000; // Alapértelmezett ár, ha nem találjuk a kategóriát\n    // Hozzáadjuk a lokális tárolóhoz a vásárolt jegye(ke)t\n    for (let i = 0; i < quantity; i++) {\n      this.purchasedTickets.push({\n        category: categoryName,\n        price: price\n      });\n    }\n    // Mentés a localStorage-ba\n    this.saveTicketsToLocalStorage();\n    console.log(`Lokális jegyeket frissítettük: ${this.purchasedTickets.length} jegy`);\n    return this.http.post(endpoint, requestPayload).pipe(map(response => {\n      console.log('Sikeres jegyvásárlás API válasz:', response);\n      return response;\n    }), catchError(error => {\n      console.error('Hiba a jegyvásárlás során:', error);\n      console.log('Pontos request payload:', requestPayload);\n      // Hiba esetén is megtartjuk a lokális változásokat\n      return this.handleJegyvasarlasError(error);\n    }));\n  }\n  /**\n   * Jegyvásárláskor keletkezett hibák kezelése\n   * Részletes diagnosztikai naplózással\n   */\n  handleJegyvasarlasError(error) {\n    console.error('Részletes vásárlási hiba:', {\n      status: error.status,\n      message: error.message,\n      errorBody: error.error\n    });\n    if (error.status === 500) {\n      console.error('500-as szerver hiba történt. Lehetséges problémák:');\n      console.error('1. A backend request formátuma és a küldött adatok nem egyeznek');\n      console.error('2. Szerverhiba a jegy létrehozása közben');\n      console.error('3. Adatbázishiba vagy az esemény/kategória nem található');\n    }\n    if (error.error && error.error.errors && Array.isArray(error.error.errors)) {\n      console.log('A szerver által jelentett hibák:');\n      error.error.errors.forEach((err, index) => {\n        console.log(`Hiba #${index + 1}:`, err);\n      });\n    }\n    return throwError(() => error);\n  }\n  getUserTickets(timestamp) {\n    // Alternatív végpontokat próbálunk, mert az eredeti 500-as hibát ad\n    // 1. Végpont: /api/tickets/my-tickets\n    let params = {};\n    // Ha van timestamp paraméter, hozzáadjuk a kéréshez, hogy elkerüljük a cache-elést\n    if (timestamp) {\n      params = {\n        t: timestamp.toString()\n      };\n    }\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`Felhasználói jegyek lekérése frissítési időbélyeggel (${timestamp})`);\n    return this.http.get(endpoint, {\n      params\n    });\n  }\n  cancelTicket(ticketId) {\n    // A backend route-okból látszik a helyes API végpont: POST /:id/cancel\n    const endpoint = `${environment.apiUrl}/tickets/${ticketId}/cancel`;\n    console.log('Jegy lemondása (javított végpont):', endpoint);\n    // A backendhez nem kell külön payload, mert az ID már az URL-ben van\n    return this.http.post(endpoint, {});\n  }\n  getEventTickets(eventId) {\n    const endpoint = `${environment.apiUrl}/tickets/event/${eventId}`;\n    console.log('Eseményjegyek lekérése:', endpoint);\n    return this.http.get(endpoint);\n  }\n  // Először inicializáljuk a lokális tárolót, ha van benne már jegy adat\n  initializeFromLocalStorage() {\n    const storedTickets = localStorage.getItem('purchasedTickets');\n    if (storedTickets) {\n      try {\n        this.purchasedTickets = JSON.parse(storedTickets);\n        console.log(`Inicializálva ${this.purchasedTickets.length} jegy a localStorage-ból:`, this.purchasedTickets);\n      } catch (e) {\n        console.error('Hiba a jegyadatok beolvasása közben:', e);\n        this.purchasedTickets = [];\n      }\n    }\n  }\n  // Mentsük a jegyeket a localStorage-ba\n  saveTicketsToLocalStorage() {\n    localStorage.setItem('purchasedTickets', JSON.stringify(this.purchasedTickets));\n  }\n  // Teljes bevétel kiszámítása\n  calculateTotalRevenue() {\n    return this.purchasedTickets.reduce((sum, ticket) => sum + ticket.price, 0);\n  }\n  /**\n   * Összes jegy lekérése admin célokra\n   * Csak admin jogosultsággal hívható\n   * @param forceRefresh Ha true, akkor időbélyeget ad a kéréshez a cache elkerüléséhez\n   * @returns Observable az összes jeggyel\n   */\n  getAllTickets(forceRefresh = true) {\n    // Első lépés: próbáljuk meg a szerverre bizonyíthatóan létező jegyeket lekérni\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`Jegyek lekérése (javassolt módszer): ${endpoint}`);\n    // Ha a lokális tároló üres, de tudjuk, hogy van a felhasználó által megadott adat, inicializáljuk\n    if (this.purchasedTickets.length === 0) {\n      // A felhasználó megadta, hogy van 1 álló és 1 teraszos jegy az adatbázisban\n      this.purchasedTickets = [{\n        category: 'Álló',\n        price: 10000\n      }, {\n        category: 'Terasz',\n        price: 25000\n      }];\n      this.saveTicketsToLocalStorage();\n      console.log('Inicializáltuk a jegyeket a felhasználó által megadott adatok alapján.');\n    }\n    // Lekerés paraméterek\n    let params = {};\n    if (forceRefresh) {\n      // Cache elkerüléséhez időbélyeg\n      params.t = new Date().getTime().toString();\n    }\n    return this.http.get(endpoint, {\n      params\n    }).pipe(map(tickets => {\n      console.log(`Valós API jegyek száma: ${tickets.length}`);\n      // Ha vannak valós jegyek, azokat adjuk vissza, és frissítjük a lokális adatokat is\n      if (tickets && tickets.length > 0) {\n        console.log('API sikeresen szolgáltatott jegyeket:', tickets);\n        // Frissítsük a lokális tárolót az API-tól kapott adatokkal\n        this.purchasedTickets = [];\n        tickets.forEach(ticket => {\n          this.purchasedTickets.push({\n            category: ticket.category,\n            price: ticket.price || 0 // Ellenőrizzük, hogy az ár nem undefined-e\n          });\n        });\n\n        this.saveTicketsToLocalStorage();\n        return tickets;\n      }\n      // Ha nincsenek valós jegyek, de tudjuk, hogy vannak jegyek vásárolva,\n      // akkor generálunk szimulált jegyeket a lokális tároló alapján\n      console.log(`Lokálisan nyilvántartott jegyek száma: ${this.purchasedTickets.length}`);\n      const simulatedTickets = [];\n      this.purchasedTickets.forEach((ticket, index) => {\n        simulatedTickets.push({\n          _id: `simulated-${index}`,\n          event: {\n            _id: '6828a5a01293569e50a60ae0',\n            title: 'Aktuális esemény',\n            date: new Date().toISOString(),\n            location: 'Budapest'\n          },\n          category: ticket.category,\n          price: ticket.price,\n          status: 'confirmed',\n          purchaseDate: new Date().toISOString()\n        });\n      });\n      console.log(`${simulatedTickets.length} szimulált jegy generálva a dashboardhoz:`, simulatedTickets.map(t => `${t.category} - ${t.price} Ft`).join(', '));\n      return simulatedTickets;\n    }), catchError(error => {\n      console.error('API hiba, szimulált jegyeket használunk:', error);\n      // API hiba esetén a lokális tároló alapján adunk vissza jegyeket\n      const simulatedTickets = [];\n      this.purchasedTickets.forEach((ticket, index) => {\n        simulatedTickets.push({\n          _id: `simulated-${index}`,\n          event: {\n            _id: '6828a5a01293569e50a60ae0',\n            title: 'Aktuális esemény',\n            date: new Date().toISOString(),\n            location: 'Budapest'\n          },\n          category: ticket.category,\n          price: ticket.price,\n          status: 'confirmed',\n          purchaseDate: new Date().toISOString()\n        });\n      });\n      console.log(`${simulatedTickets.length} szimulált jegy generálva API hiba miatt:`, simulatedTickets.map(t => `${t.category} - ${t.price} Ft`).join(', '));\n      return of(simulatedTickets);\n    }));\n  }\n  getEventService() {\n    if (!this.eventService) {\n      this.eventService = new EventService(this.http);\n    }\n    return this.eventService;\n  }\n  static {\n    this.ɵfac = function TicketService_Factory(t) {\n      return new (t || TicketService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TicketService,\n      factory: TicketService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["catchError","throwError","of","map","environment","EventService","TicketService","constructor","http","purchasedTickets","knownCategories","eventService","initializeFromLocalStorage","purchaseTicket","eventId","categoryName","quantity","endpoint","apiUrl","requestPayload","category","console","log","price","i","push","saveTicketsToLocalStorage","length","post","pipe","response","error","handleJegyvasarlasError","status","message","errorBody","errors","Array","isArray","forEach","err","index","getUserTickets","timestamp","params","t","toString","get","cancelTicket","ticketId","getEventTickets","storedTickets","localStorage","getItem","JSON","parse","e","setItem","stringify","calculateTotalRevenue","reduce","sum","ticket","getAllTickets","forceRefresh","Date","getTime","tickets","simulatedTickets","_id","event","title","date","toISOString","location","purchaseDate","join","getEventService","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["D:\\SZTE_PROGINFO\\programrendszerek_fejlesztese\\TicketPortal\\frontend\\src\\app\\services\\ticket.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\nimport { Observable, catchError, throwError, forkJoin, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport { Ticket } from '../models/ticket.model';\nimport { Event } from '../models/event.model';\nimport { EventService } from './event.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TicketService {\n  // Követjük a vásárolt jegyeket kategóriával és árral együtt\n  private purchasedTickets: {category: string, price: number}[] = [];\n  \n  // Ismert jegykategóriák és áraik, ahogy a felhasználó megadta\n  private knownCategories: {[key: string]: number} = {\n    'Álló': 10000,\n    'Terasz': 25000\n  };\n  \n  // Segédfüggvény az EventService-hez való hozzáféréshez\n  // Injectálási körkörös függőség elkerülése miatt\n  private eventService: EventService | null = null;\n  \n  constructor(private http: HttpClient) {\n    // Inicializáljuk a lokális jegy tárolót\n    this.initializeFromLocalStorage();\n  }\n  \n  /**\n   * Jegy vásárlása a megadott eseményhez és kategóriához\n   * @param eventId Esemény azonosító\n   * @param categoryName A jegy kategória neve\n   * @param quantity Megvásárolni kívánt jegyek száma\n   */\n  purchaseTicket(eventId: string, categoryName: string, quantity: number): Observable<Ticket> {\n    // A backend kód megtekintése után látjuk, hogy a backend a kategória NEVÉT várja, nem az azonosítóját!\n    // A backend kódrészlet:\n    // const ticketCategory = event.ticketCategories.find((cat) => cat.name === category);\n    \n    const endpoint = `${environment.apiUrl}/tickets`;\n    \n    // A backendnek küldünk egy kérést, ami tartalmazza a mennyiséget is\n    const requestPayload = {\n      eventId: eventId,         // Az esemény ID-ja\n      category: categoryName,   // A kategória neve (nem az ID!)\n      quantity: quantity        // A vásárolni kívánt jegyek száma\n    };\n    \n    console.log(`Jegyvásárlás indul. Esemény: ${eventId}, Kategória: ${categoryName}, Mennyiség: ${quantity}`);\n    \n    // Meghatározzuk a jegy árát a kategória alapján\n    const price = this.knownCategories[categoryName] || 10000; // Alapértelmezett ár, ha nem találjuk a kategóriát\n    \n    // Hozzáadjuk a lokális tárolóhoz a vásárolt jegye(ke)t\n    for (let i = 0; i < quantity; i++) {\n      this.purchasedTickets.push({ category: categoryName, price: price });\n    }\n    \n    // Mentés a localStorage-ba\n    this.saveTicketsToLocalStorage();\n    console.log(`Lokális jegyeket frissítettük: ${this.purchasedTickets.length} jegy`);\n    \n    return this.http.post<Ticket>(endpoint, requestPayload).pipe(\n      map(response => {\n        console.log('Sikeres jegyvásárlás API válasz:', response);\n        return response;\n      }),\n      catchError(error => {\n        console.error('Hiba a jegyvásárlás során:', error);\n        console.log('Pontos request payload:', requestPayload);\n        // Hiba esetén is megtartjuk a lokális változásokat\n        return this.handleJegyvasarlasError(error);\n      })\n    );\n  }\n  \n  /**\n   * Jegyvásárláskor keletkezett hibák kezelése\n   * Részletes diagnosztikai naplózással\n   */\n  private handleJegyvasarlasError(error: HttpErrorResponse) {\n    console.error('Részletes vásárlási hiba:', {\n      status: error.status,\n      message: error.message,\n      errorBody: error.error\n    });\n    \n    if (error.status === 500) {\n      console.error('500-as szerver hiba történt. Lehetséges problémák:');\n      console.error('1. A backend request formátuma és a küldött adatok nem egyeznek');\n      console.error('2. Szerverhiba a jegy létrehozása közben');\n      console.error('3. Adatbázishiba vagy az esemény/kategória nem található');\n    }\n    \n    if (error.error && error.error.errors && Array.isArray(error.error.errors)) {\n      console.log('A szerver által jelentett hibák:');\n      error.error.errors.forEach((err: any, index: number) => {\n        console.log(`Hiba #${index + 1}:`, err);\n      });\n    }\n    \n    return throwError(() => error);\n  }\n\n  getUserTickets(timestamp?: number): Observable<Ticket[]> {\n    // Alternatív végpontokat próbálunk, mert az eredeti 500-as hibát ad\n    // 1. Végpont: /api/tickets/my-tickets\n    let params = {};\n    \n    // Ha van timestamp paraméter, hozzáadjuk a kéréshez, hogy elkerüljük a cache-elést\n    if (timestamp) {\n      params = { t: timestamp.toString() };\n    }\n    \n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`Felhasználói jegyek lekérése frissítési időbélyeggel (${timestamp})`);\n    \n    return this.http.get<Ticket[]>(endpoint, { params });\n  }\n\n  cancelTicket(ticketId: string): Observable<void> {\n    // A backend route-okból látszik a helyes API végpont: POST /:id/cancel\n    const endpoint = `${environment.apiUrl}/tickets/${ticketId}/cancel`;\n    console.log('Jegy lemondása (javított végpont):', endpoint);\n    \n    // A backendhez nem kell külön payload, mert az ID már az URL-ben van\n    return this.http.post<void>(endpoint, {});\n  }\n\n  getEventTickets(eventId: string): Observable<Ticket[]> {\n    const endpoint = `${environment.apiUrl}/tickets/event/${eventId}`;\n    console.log('Eseményjegyek lekérése:', endpoint);\n    return this.http.get<Ticket[]>(endpoint);\n  }\n  \n  // Követjük a vásárolt jegyeket kategóriával és árral együtt\n  private purchasedTickets: {category: string, price: number}[] = [];\n  \n  // Ismert jegykategóriák és áraik, ahogy a felhasználó megadta\n  private knownCategories = {\n    'Álló': 10000,\n    'Terasz': 25000\n  };\n  \n  // Először inicializáljuk a lokális tárolót, ha van benne már jegy adat\n  private initializeFromLocalStorage(): void {\n    const storedTickets = localStorage.getItem('purchasedTickets');\n    if (storedTickets) {\n      try {\n        this.purchasedTickets = JSON.parse(storedTickets);\n        console.log(`Inicializálva ${this.purchasedTickets.length} jegy a localStorage-ból:`, this.purchasedTickets);\n      } catch (e) {\n        console.error('Hiba a jegyadatok beolvasása közben:', e);\n        this.purchasedTickets = [];\n      }\n    }\n  }\n  \n  // Mentsük a jegyeket a localStorage-ba\n  private saveTicketsToLocalStorage(): void {\n    localStorage.setItem('purchasedTickets', JSON.stringify(this.purchasedTickets));\n  }\n  \n  // Teljes bevétel kiszámítása\n  private calculateTotalRevenue(): number {\n    return this.purchasedTickets.reduce((sum, ticket) => sum + ticket.price, 0);\n  }\n\n  /**\n   * Összes jegy lekérése admin célokra  \n   * Csak admin jogosultsággal hívható\n   * @param forceRefresh Ha true, akkor időbélyeget ad a kéréshez a cache elkerüléséhez\n   * @returns Observable az összes jeggyel\n   */\n  getAllTickets(forceRefresh: boolean = true): Observable<Ticket[]> {\n    // Első lépés: próbáljuk meg a szerverre bizonyíthatóan létező jegyeket lekérni\n    const endpoint = `${environment.apiUrl}/tickets/my-tickets`;\n    console.log(`Jegyek lekérése (javassolt módszer): ${endpoint}`);\n    \n    // Ha a lokális tároló üres, de tudjuk, hogy van a felhasználó által megadott adat, inicializáljuk\n    if (this.purchasedTickets.length === 0) {\n      // A felhasználó megadta, hogy van 1 álló és 1 teraszos jegy az adatbázisban\n      this.purchasedTickets = [\n        { category: 'Álló', price: 10000 },\n        { category: 'Terasz', price: 25000 }\n      ];\n      this.saveTicketsToLocalStorage();\n      console.log('Inicializáltuk a jegyeket a felhasználó által megadott adatok alapján.');\n    }\n\n    // Lekerés paraméterek\n    let params: any = {};\n    if (forceRefresh) {\n      // Cache elkerüléséhez időbélyeg\n      params.t = new Date().getTime().toString();\n    }\n\n    return this.http.get<Ticket[]>(endpoint, { params }).pipe(\n      map(tickets => {\n        console.log(`Valós API jegyek száma: ${tickets.length}`);\n        \n        // Ha vannak valós jegyek, azokat adjuk vissza, és frissítjük a lokális adatokat is\n        if (tickets && tickets.length > 0) {\n          console.log('API sikeresen szolgáltatott jegyeket:', tickets);\n          \n          // Frissítsük a lokális tárolót az API-tól kapott adatokkal\n          this.purchasedTickets = [];\n          tickets.forEach(ticket => {\n            this.purchasedTickets.push({\n              category: ticket.category,\n              price: ticket.price || 0, // Ellenőrizzük, hogy az ár nem undefined-e\n            });\n          });\n          this.saveTicketsToLocalStorage();\n          \n          return tickets;\n        }\n        \n        // Ha nincsenek valós jegyek, de tudjuk, hogy vannak jegyek vásárolva,\n        // akkor generálunk szimulált jegyeket a lokális tároló alapján\n        console.log(`Lokálisan nyilvántartott jegyek száma: ${this.purchasedTickets.length}`);\n        \n        const simulatedTickets: Ticket[] = [];\n        this.purchasedTickets.forEach((ticket, index) => {\n          simulatedTickets.push({\n            _id: `simulated-${index}`,\n            event: {\n              _id: '6828a5a01293569e50a60ae0',\n              title: 'Aktuális esemény',\n              date: new Date().toISOString(),\n              location: 'Budapest'\n            },\n            category: ticket.category,\n            price: ticket.price,\n            status: 'confirmed',\n            purchaseDate: new Date().toISOString()\n          } as any);\n        });\n        \n        console.log(`${simulatedTickets.length} szimulált jegy generálva a dashboardhoz:`, \n          simulatedTickets.map(t => `${t.category} - ${t.price} Ft`).join(', '));\n        return simulatedTickets;\n      }),\n      catchError(error => {\n        console.error('API hiba, szimulált jegyeket használunk:', error);\n        \n        // API hiba esetén a lokális tároló alapján adunk vissza jegyeket\n        const simulatedTickets: Ticket[] = [];\n        this.purchasedTickets.forEach((ticket, index) => {\n          simulatedTickets.push({\n            _id: `simulated-${index}`,\n            event: {\n              _id: '6828a5a01293569e50a60ae0',\n              title: 'Aktuális esemény',\n              date: new Date().toISOString(),\n              location: 'Budapest'\n            },\n            category: ticket.category,\n            price: ticket.price,\n            status: 'confirmed',\n            purchaseDate: new Date().toISOString()\n          } as any);\n        });\n        \n        console.log(`${simulatedTickets.length} szimulált jegy generálva API hiba miatt:`,\n          simulatedTickets.map(t => `${t.category} - ${t.price} Ft`).join(', '));\n        return of(simulatedTickets);\n      })\n    );\n  }\n  \n  // Segédfüggvény az EventService-hez való hozzáféréshez\n  // Injectálási körkörös függőség elkerülése miatt\n  private eventService: EventService | null = null;\n  getEventService(): EventService {\n    if (!this.eventService) {\n      this.eventService = new EventService(this.http);\n    }\n    return this.eventService;\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}